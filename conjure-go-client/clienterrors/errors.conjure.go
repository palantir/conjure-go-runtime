// Copyright (c) 2021 Palantir Technologies. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file was generated by Conjure and should not be manually edited.

package clienterrors

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type canceledByClient struct {
}

func (o canceledByClient) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *canceledByClient) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCanceledByClient returns new instance of CanceledByClient error.
func NewCanceledByClient() *CanceledByClient {
	return &CanceledByClient{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), canceledByClient: canceledByClient{}}
}

// WrapWithCanceledByClient returns new instance of CanceledByClient error wrapping an existing error.
func WrapWithCanceledByClient(err error) *CanceledByClient {
	return &CanceledByClient{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, canceledByClient: canceledByClient{}}
}

// CanceledByClient is an error type.
type CanceledByClient struct {
	errorInstanceID uuid.UUID
	canceledByClient
	cause error
	stack werror.StackTrace
}

// IsCanceledByClient returns true if err is an instance of CanceledByClient.
func IsCanceledByClient(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CanceledByClient)
	return ok
}

func (e *CanceledByClient) Error() string {
	return fmt.Sprintf("INTERNAL HttpClient:CanceledByClient (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CanceledByClient) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CanceledByClient) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CanceledByClient) Message() string {
	return "INTERNAL HttpClient:CanceledByClient"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CanceledByClient) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CanceledByClient) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *CanceledByClient) Name() string {
	return "HttpClient:CanceledByClient"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CanceledByClient) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CanceledByClient) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CanceledByClient) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CanceledByClient) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CanceledByClient) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CanceledByClient) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CanceledByClient) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.canceledByClient)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "HttpClient:CanceledByClient", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CanceledByClient) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters canceledByClient
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.canceledByClient = parameters
	return nil
}

type connectionRefused struct {
	Address string `json:"address"`
}

func (o connectionRefused) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *connectionRefused) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConnectionRefused returns new instance of ConnectionRefused error.
func NewConnectionRefused(addressArg string) *ConnectionRefused {
	return &ConnectionRefused{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), connectionRefused: connectionRefused{Address: addressArg}}
}

// WrapWithConnectionRefused returns new instance of ConnectionRefused error wrapping an existing error.
func WrapWithConnectionRefused(err error, addressArg string) *ConnectionRefused {
	return &ConnectionRefused{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, connectionRefused: connectionRefused{Address: addressArg}}
}

// ConnectionRefused is an error type.
type ConnectionRefused struct {
	errorInstanceID uuid.UUID
	connectionRefused
	cause error
	stack werror.StackTrace
}

// IsConnectionRefused returns true if err is an instance of ConnectionRefused.
func IsConnectionRefused(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConnectionRefused)
	return ok
}

func (e *ConnectionRefused) Error() string {
	return fmt.Sprintf("INTERNAL HttpClient:ConnectionRefused (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConnectionRefused) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConnectionRefused) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConnectionRefused) Message() string {
	return "INTERNAL HttpClient:ConnectionRefused"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConnectionRefused) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConnectionRefused) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *ConnectionRefused) Name() string {
	return "HttpClient:ConnectionRefused"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConnectionRefused) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConnectionRefused) Parameters() map[string]interface{} {
	return map[string]interface{}{"address": e.Address}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConnectionRefused) safeParams() map[string]interface{} {
	return map[string]interface{}{"address": e.Address, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConnectionRefused) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConnectionRefused) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConnectionRefused) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConnectionRefused) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.connectionRefused)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "HttpClient:ConnectionRefused", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConnectionRefused) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters connectionRefused
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.connectionRefused = parameters
	return nil
}

type dialTimeout struct {
	Address string `json:"address"`
}

func (o dialTimeout) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *dialTimeout) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDialTimeout returns new instance of DialTimeout error.
func NewDialTimeout(addressArg string) *DialTimeout {
	return &DialTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), dialTimeout: dialTimeout{Address: addressArg}}
}

// WrapWithDialTimeout returns new instance of DialTimeout error wrapping an existing error.
func WrapWithDialTimeout(err error, addressArg string) *DialTimeout {
	return &DialTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, dialTimeout: dialTimeout{Address: addressArg}}
}

// DialTimeout is an error type.
type DialTimeout struct {
	errorInstanceID uuid.UUID
	dialTimeout
	cause error
	stack werror.StackTrace
}

// IsDialTimeout returns true if err is an instance of DialTimeout.
func IsDialTimeout(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DialTimeout)
	return ok
}

func (e *DialTimeout) Error() string {
	return fmt.Sprintf("TIMEOUT HttpClient:DialTimeout (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DialTimeout) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DialTimeout) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DialTimeout) Message() string {
	return "TIMEOUT HttpClient:DialTimeout"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DialTimeout) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DialTimeout) Code() errors.ErrorCode {
	return errors.Timeout
}

// Name returns an error name identifying error type.
func (e *DialTimeout) Name() string {
	return "HttpClient:DialTimeout"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DialTimeout) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DialTimeout) Parameters() map[string]interface{} {
	return map[string]interface{}{"address": e.Address}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DialTimeout) safeParams() map[string]interface{} {
	return map[string]interface{}{"address": e.Address, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DialTimeout) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DialTimeout) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DialTimeout) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DialTimeout) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.dialTimeout)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Timeout, ErrorName: "HttpClient:DialTimeout", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DialTimeout) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters dialTimeout
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.dialTimeout = parameters
	return nil
}

type dnsLookupFailed struct {
	Address string `json:"address"`
}

func (o dnsLookupFailed) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *dnsLookupFailed) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDnsLookupFailed returns new instance of DnsLookupFailed error.
func NewDnsLookupFailed(addressArg string) *DnsLookupFailed {
	return &DnsLookupFailed{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), dnsLookupFailed: dnsLookupFailed{Address: addressArg}}
}

// WrapWithDnsLookupFailed returns new instance of DnsLookupFailed error wrapping an existing error.
func WrapWithDnsLookupFailed(err error, addressArg string) *DnsLookupFailed {
	return &DnsLookupFailed{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, dnsLookupFailed: dnsLookupFailed{Address: addressArg}}
}

// DnsLookupFailed is an error type.
type DnsLookupFailed struct {
	errorInstanceID uuid.UUID
	dnsLookupFailed
	cause error
	stack werror.StackTrace
}

// IsDnsLookupFailed returns true if err is an instance of DnsLookupFailed.
func IsDnsLookupFailed(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DnsLookupFailed)
	return ok
}

func (e *DnsLookupFailed) Error() string {
	return fmt.Sprintf("INTERNAL HttpClient:DnsLookupFailed (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DnsLookupFailed) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DnsLookupFailed) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DnsLookupFailed) Message() string {
	return "INTERNAL HttpClient:DnsLookupFailed"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DnsLookupFailed) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DnsLookupFailed) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *DnsLookupFailed) Name() string {
	return "HttpClient:DnsLookupFailed"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DnsLookupFailed) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DnsLookupFailed) Parameters() map[string]interface{} {
	return map[string]interface{}{"address": e.Address}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DnsLookupFailed) safeParams() map[string]interface{} {
	return map[string]interface{}{"address": e.Address, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DnsLookupFailed) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DnsLookupFailed) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DnsLookupFailed) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DnsLookupFailed) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.dnsLookupFailed)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "HttpClient:DnsLookupFailed", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DnsLookupFailed) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters dnsLookupFailed
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.dnsLookupFailed = parameters
	return nil
}

type dnsNoSuchHost struct {
	Address string `json:"address"`
}

func (o dnsNoSuchHost) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *dnsNoSuchHost) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDnsNoSuchHost returns new instance of DnsNoSuchHost error.
func NewDnsNoSuchHost(addressArg string) *DnsNoSuchHost {
	return &DnsNoSuchHost{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), dnsNoSuchHost: dnsNoSuchHost{Address: addressArg}}
}

// WrapWithDnsNoSuchHost returns new instance of DnsNoSuchHost error wrapping an existing error.
func WrapWithDnsNoSuchHost(err error, addressArg string) *DnsNoSuchHost {
	return &DnsNoSuchHost{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, dnsNoSuchHost: dnsNoSuchHost{Address: addressArg}}
}

// DnsNoSuchHost is an error type.
type DnsNoSuchHost struct {
	errorInstanceID uuid.UUID
	dnsNoSuchHost
	cause error
	stack werror.StackTrace
}

// IsDnsNoSuchHost returns true if err is an instance of DnsNoSuchHost.
func IsDnsNoSuchHost(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DnsNoSuchHost)
	return ok
}

func (e *DnsNoSuchHost) Error() string {
	return fmt.Sprintf("INTERNAL HttpClient:DnsNoSuchHost (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DnsNoSuchHost) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DnsNoSuchHost) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DnsNoSuchHost) Message() string {
	return "INTERNAL HttpClient:DnsNoSuchHost"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DnsNoSuchHost) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DnsNoSuchHost) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *DnsNoSuchHost) Name() string {
	return "HttpClient:DnsNoSuchHost"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DnsNoSuchHost) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DnsNoSuchHost) Parameters() map[string]interface{} {
	return map[string]interface{}{"address": e.Address}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DnsNoSuchHost) safeParams() map[string]interface{} {
	return map[string]interface{}{"address": e.Address, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DnsNoSuchHost) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DnsNoSuchHost) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DnsNoSuchHost) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DnsNoSuchHost) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.dnsNoSuchHost)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "HttpClient:DnsNoSuchHost", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DnsNoSuchHost) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters dnsNoSuchHost
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.dnsNoSuchHost = parameters
	return nil
}

type dnsTimeout struct {
	Address string `json:"address"`
}

func (o dnsTimeout) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *dnsTimeout) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDnsTimeout returns new instance of DnsTimeout error.
func NewDnsTimeout(addressArg string) *DnsTimeout {
	return &DnsTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), dnsTimeout: dnsTimeout{Address: addressArg}}
}

// WrapWithDnsTimeout returns new instance of DnsTimeout error wrapping an existing error.
func WrapWithDnsTimeout(err error, addressArg string) *DnsTimeout {
	return &DnsTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, dnsTimeout: dnsTimeout{Address: addressArg}}
}

// DnsTimeout is an error type.
type DnsTimeout struct {
	errorInstanceID uuid.UUID
	dnsTimeout
	cause error
	stack werror.StackTrace
}

// IsDnsTimeout returns true if err is an instance of DnsTimeout.
func IsDnsTimeout(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DnsTimeout)
	return ok
}

func (e *DnsTimeout) Error() string {
	return fmt.Sprintf("INTERNAL HttpClient:DnsTimeout (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DnsTimeout) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DnsTimeout) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DnsTimeout) Message() string {
	return "INTERNAL HttpClient:DnsTimeout"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DnsTimeout) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DnsTimeout) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *DnsTimeout) Name() string {
	return "HttpClient:DnsTimeout"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DnsTimeout) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DnsTimeout) Parameters() map[string]interface{} {
	return map[string]interface{}{"address": e.Address}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DnsTimeout) safeParams() map[string]interface{} {
	return map[string]interface{}{"address": e.Address, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DnsTimeout) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DnsTimeout) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DnsTimeout) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DnsTimeout) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.dnsTimeout)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "HttpClient:DnsTimeout", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DnsTimeout) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters dnsTimeout
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.dnsTimeout = parameters
	return nil
}

func init() {
	errors.RegisterErrorType("HttpClient:CanceledByClient", reflect.TypeOf(CanceledByClient{}))
	errors.RegisterErrorType("HttpClient:ConnectionRefused", reflect.TypeOf(ConnectionRefused{}))
	errors.RegisterErrorType("HttpClient:DialTimeout", reflect.TypeOf(DialTimeout{}))
	errors.RegisterErrorType("HttpClient:DnsLookupFailed", reflect.TypeOf(DnsLookupFailed{}))
	errors.RegisterErrorType("HttpClient:DnsNoSuchHost", reflect.TypeOf(DnsNoSuchHost{}))
	errors.RegisterErrorType("HttpClient:DnsTimeout", reflect.TypeOf(DnsTimeout{}))
}
